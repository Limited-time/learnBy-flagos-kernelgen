# 昇腾AI算法挑战赛高阶赛-Broadcast算子优化任务书
文档版本：V0.1
发布日期：2025-09-19
出品方：华为技术有限公司

## 修订记录
| 版本 | 修改说明 | 发布时间   |
| :--- | :------- | :--------- |
| V0.1 | -        | 2025-09-19 |

## 1 赛题简介
在人工智能的时代浪潮中，各类大模型的发展突飞猛进，加速各行业应用创新。进入2025年，大语言模型(LLMs)快速迭代与进化，特别是在推理能力和运行效率方面有了显著提升：
- 推理能力上，以OpenAI o1系列和DeepSeek R1为代表的推理模型，带来了scaling law范式的转移(inference-time scaling)，擅长解决解谜、高级数学和编码等复杂任务，将大模型推向更广泛的应用场景；
- 运行效率上，以量化、MOE、知识蒸馏为代表的模型优化技术，使得大模型可以部署到更轻量化的设备上，给端侧AI带来更大的想象空间。

在参数量、算力需求指数倍增长的情况下，充分释放AI芯片算力、提升大模型性价比成为AI领域的关键技术，**高性能算子的实现与优化**是达成此目标的基础。本次比赛要求选手对Ascend C Broadcast算子进行优化，具体要求如下：
1. 基于昇腾AI云服务，使用AI芯片Ascend-snt9b、AI异构计算框架CANN、AI应用开发平台ModelArts等华为全栈AI技术，增强模型推理能力并提升性能；
2. 参赛团队需掌握华为昇腾AI处理器架构、CANN软件栈与ModelArts开发环境，实现昇腾算子开发，完成相关技术学习与实践操作。

## 2 题目背景说明
### 2.1 题目信息
#### 2.1.1 问题抽象
Ascend C是CANN针对算子开发场景推出的编程语言，原生支持C和C++标准规范，兼具开发效率和运行性能。基于Ascend C编写的算子程序，经编译器编译和运行时调度后，可运行在昇腾AI处理器上，开发者能基于昇腾AI硬件高效实现自定义的创新算法，整体执行流程为：**Ascend C编写算子程序 → 编译器编译 → 昇腾AI处理器运行**。

##### 昇腾AI处理器核心架构
昇腾AI处理器中，**AI Core**负责执行标量、向量和张量相关的计算密集型算子，包含计算单元、存储单元、控制单元，同时配备数据搬运的搬运单元；硬件架构根据Cube计算单元和Vector计算单元是否同核部署，分为耦合架构和分离架构两种。Ascend C基于硬件抽象架构进行编程，可屏蔽不同硬件之间的差异。

AI Core是算子执行的核心，内部包含Scalar计算单元、Vector计算单元、Cube计算单元、DMA搬运单元、Local Memory等核心组件，外部对接Global Memory，通过**指令流、数据流、同步信号**协同完成算子计算，各组件的具体功能如下表：

| 组件分类 | 组件名称                   | 组件功能                                                     |
| :------- | :------------------------- | :----------------------------------------------------------- |
| 计算单元 | Scalar                     | 执行地址计算、循环控制等标量计算工作，并把向量计算、矩阵计算、数据搬运、同步指令发射给对应单元执行。 |
| 计算单元 | Vector                     | 负责执行向量运算。                                           |
| 计算单元 | Cube                       | 负责执行矩阵运算。                                           |
| 存储单元 | Local Memory               | AI Core的内部存储，对应的数据类型为LocalTensor，因芯片硬件资源不同，可分为UB、L1、L0A、L0B等。 |
| 存储单元 | Global Memory              | AI Core能够访问的外部存储，对应的数据类型为GlobalTensor。    |
| 搬运单元 | DMA (Direct Memory Access) | 负责数据搬运，包括Global Memory和Local Memory之间的数据搬运，以及不同层级Local Memory之间的数据搬运；包含MTE2(数据搬入单元)、MTE3(数据搬出单元)等子单元。 |

#### 2.1.2 Broadcast算子简介和描述
Broadcast算子是深度学习中的基础算子，广泛应用于张量形状扩展（如加法、乘法等元素级运算前的维度对齐），但在**高维Shape场景**下，当前CANN中的Broadcast算子存在性能瓶颈，计算耗时长，影响整体模型训练和推理效率。

##### 算子核心实现逻辑
通过Broadcast机制，可将维度不匹配的张量扩展为相同形状，满足元素级运算的维度要求，示例如下：
- 张量A：shape=[3,1]，值为`[[1],[2],[3]]`
- 张量B：shape=[1,4]，值为`[[10, 20, 30, 40]]`
- 经Broadcast后，A、B均扩展为shape=[3,4]，再执行加法运算得到结果。
  ```
  A' = [[1,1,1,1],[2,2,2,2],[3,3,3,3]]
  B' = [[10,20,30,40],[10,20,30,40],[10,20,30,40]]
  A'+B' = [[11,21,31,41],[12,22,32,42],[13,23,33,43]]
  ```

##### Broadcast核心规则
1. 对齐维度：从尾部（最内层）开始对齐两个张量的shape；
2. 维度扩展：若某维大小为1，可扩展为任意大小；
3. 自动填充：若某一侧维度缺失，自动填充为1。

**匹配示例**：
- [3,1]+[1,4] → [3,4]（符合规则，可广播）
- [2,3,4]+[3,4] → [2,3,4]（符合规则，可广播）
- [2,3]+[3,2] → 不匹配（无法广播）

##### 典型应用场景
1. 激活函数偏置加法：输入张量[batch, channel, height, width]，偏置张量[channel]，通过Broadcast将偏置扩展至每个空间位置；
2. BatchNorm中的缩放与偏移：scale和bias为[channel]，需广播至输入张量以完成缩放和偏移计算；
3. Attention中的Masking：Mask张量通常为[batch, 1, 1, seq_len]，需广播至[batch, heads, seq_len, seq_len]以完成掩码操作。

### 2.2 算子工程介绍
#### 2.2.1 工程目录结构
Broadcast自定义算子工程目录为**BroadcastCustom**，核心分为host侧和kernel侧实现文件，目录结构如下：
```
BroadcastCustom/
├── op_host/  # host侧实现文件
└── op_kernel/ # kernel侧实现文件
```

#### 2.2.2 工程创建与编译
1. CANN软件包提供工程创建工具`msOpGen`，可通过`BroadcastCustom.json`自动创建BroadcastCustom算子工程，具体参考Ascend C算子开发>工程化算子开发>创建算子工程章节；
2. 开发者需重点完成算子host和kernel文件的功能开发；
3. 工程提供`install.sh`脚本简化运行流程，该脚本会创建**CustomOp**生成目录，将算子实现文件复制至对应目录并完成编译；
   > 注意：CustomOp为生成目录，每次执行install.sh都会删除并重新生成，切勿在此目录下编码算子，避免代码丢失。

## 3 任务说明
### 3.1 任务要求
Broadcast算子用于将低维张量扩展至高维以匹配运算维度，当前在**高维Shape场景（如[batch, 1024, 1024, 256]）**下存在显著性能瓶颈，表现为计算耗时长、内存占用高，直接影响模型训练/推理效率，本次比赛需针对该问题完成算子优化。

### 3.2 关键技术方向（参考建议）
本次算子优化可从**动态Shape处理、内存访问、计算流程重构**三个核心方向入手，针对各方向的现存问题和优化要求如下：

#### 3.2.1 动态Shape处理优化
- **现存问题**：运行时动态Shape分支判断导致额外开销；
- **优化要求**：基于range参数预分配资源，减少分支跳转；实现自适应Tiling策略，支持超大规模张量（如shape=-1场景）。

#### 3.2.2 内存访问优化
- **现存问题**：高维下内存非连续访问、对齐效率低；
- **优化要求**：优化数据分块(Blocking)策略，提升局部性；复用统一缓冲区(UB)，减少全局内存访问次数；确保内存访问对齐至硬件位宽（如256B）。

#### 3.2.3 计算流程重构
- **现存问题**：串行复制操作未充分利用多核并行；
- **优化要求**：设计多核并行广播策略（如分块并行+核内流水）；应用向量化指令(SIMD)加速数据复制；探索异步计算掩盖内存延迟。

## 4 交付要求
参赛团队需完成**代码交付、结果验证、文档输出**三部分内容，具体要求如下：
1. **代码交付**
   - 算子实现代码行数≤2000行，禁用黑盒API；
   - 提供APROF性能分析报告及瓶颈定位说明。
2. **验证标准**
   - 测试用例需覆盖典型高维场景，包括Shape=[2048,2048,2048]、[4096,1024,4096]等。
3. **文档输出**
   - 提供优化技术说明文档，文档中需包含Roofline模型瓶颈分析。

## 5 评分标准
本次比赛评分分为**精度正确性、性能表现、泛化能力、代码规范性、文档完整性**五个维度，各维度权重及细则说明如下表：

| 维度       | 权重 | 细则说明                                                     |
| :--------- | :--- | :----------------------------------------------------------- |
| 精度正确性 | 30%  | 所有测试Shape下结果必须与参考实现（如PyTorch/CANN）对齐，误差控制在IEEE FP16/BF16标准内。 |
| 性能表现   | 50%  | 在5个Shape中分别进行性能打分，采用相对评分法，对所有精度正确的选手按执行时间从快到慢排名。 |
| 泛化能力   | 10%  | 泛化场景中（未公开Shape）性能是否稳定，是否能应对动态Shape输入。 |
| 代码规范性 | 5%   | 包括代码可读性、注释完整性、是否符合Ascend开发规范（TBE/CCE）等。 |
| 文档完整性 | 5%   | 提交说明文档是否完整，是否包含优化思路、性能瓶颈分析、Roofline模型、调优过程等。 |

### 5.1 测试Shape说明
测试用例包含典型高维、中维、低维及泛化场景，所有Shape均不公开，具体示例如下表，**所有Shape需在Ascend NPU（如910B）上运行**，使用msprof或APROF工具记录端到端耗时。

| Shape编号 | 输入Shape (M, K, N) | 类型     | 是否公开 |
| :-------- | :------------------ | :------- | :------- |
| S1        | (2048, 2048, 2048)  | 高维典型 | ❌ 否     |
| S2        | (4096, 1024, 4096)  | 高维典型 | ❌ 否     |
| S3        | (1024, 512, 1024)   | 中维     | ❌ 否     |
| S4        | (512, 128, 512)     | 低维     | ❌ 否     |
| S5~S8     | (动态生成)          | 泛化场景 | ❌ 否     |

### 5.2 性能评分方式详解
#### 5.2.1 精度验证（30分）
- 所有测试Shape需通过精度校验，**逐元素误差 ≤1e-3**；
- 若任一Shape精度失败，则该选手性能部分得分为0。

#### 5.2.2 性能排名打分（50分）
- 每个Shape按执行时间从低到高排序，设共有M名精度合格选手；
- 排名计分公式：第n名得分 = 50 × (M-n+1) / M（第1名得50分）；
- 所有Shape得分加权平均，得到最终性能得分。

#### 5.2.3 泛化能力评分（10分）
- 计分公式：泛化Shape性能得分 = 泛化场景平均性能排名得分 × 10%；
- 若未支持动态Shape输入，此项得分减半。

#### 5.2.4 代码规范性与文档完整性（各5分）
根据代码的开发规范符合性、可读性、注释完整性，以及文档的信息完整性、分析深度进行综合打分。

## 6 注意事项
1. 判题程序会从选手程序标准输出读取分配方案，计算调度总得分并记录程序运行时间（单位为ms），总得分高的方案胜出；
2. 若不同选手的输出方案总得分相同，则先提交代码者胜出；
3. 判题采用多组数据，得分依据多组结果求和后进行排名；
4. 禁止在代码中执行shell命令、使用多线程等影响判题机器运行与公平性的行为，该行为在赛后最终测评阶段也将无法得分；
5. 比赛结束后将进行代码查验，如发现代码重复或违规等情况，将取消该团队参赛资格和现有成绩；
6. 程序运行总时间不超过1分钟，超时则判题失败；
7. 所有选手提交代码后，统一在指定设备上运行精度校验，精度通过者进入性能测试，记录各Shape执行时间并按规则汇总得分，结合加分/扣分项给出最终评分，对前10%选手进行人工复核，确保评分客观性；
8. 可借鉴参考开源代码，但必须有相应的原创、创新；比赛结束后将进行代码查验和复测，如发现代码重复、搬运、抄袭、重复率过高的作品，经查实后将取消获奖资格。

> 重要提示：因进程调用存在一定的时间开销，用时统计在判题程序侧和选手程序侧可能存在细微差异，建议选手控制算法用时的时候留有一定的冗余。