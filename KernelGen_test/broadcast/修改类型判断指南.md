# 如何判断修改类型：性能参数 vs 接口 vs 逻辑

## 目录
1. [三大修改类型定义](#三大修改类型定义)
2. [判断流程图](#判断流程图)
3. [详细判断标准](#详细判断标准)
4. [实战案例解析](#实战案例解析)
5. [快速检查清单](#快速检查清单)

---

## 三大修改类型定义

### 1. 性能参数修改（Performance Parameters）

**定义**：只影响内核执行效率，不改变计算结果和函数接口的参数

**特点**：
- ✅ 不改变输入输出的类型、形状、语义
- ✅ 不改变计算逻辑和数学公式
- ✅ 只调整GPU执行策略
- ✅ 修改后其他三个文件**完全不用动**

**常见参数**：
```python
# Triton内核调用时的性能参数
_broadcast_v1_kernel[grid](
    x_c, bias_c, out,
    P, D,
    stride_row, stride_row,
    BLOCK_M=32,      # ← 性能参数
    BLOCK_N=512,     # ← 性能参数
    num_warps=4,     # ← 性能参数
    num_stages=3,    # ← 性能参数
)
```

### 2. 接口修改（Interface Changes）

**定义**：改变函数的输入输出定义、类型约束或形状要求

**特点**：
- ❌ 改变函数签名（参数个数、类型）
- ❌ 改变输入输出形状要求
- ❌ 改变数据类型要求
- ✅ 必须同步修改所有四个文件

**常见接口修改**：
```python
# 修改前
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    pass

# 修改后：添加新参数
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor, scale: float = 1.0) -> torch.Tensor:
    pass

# 修改后：改变数据类型要求
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    assert x.dtype == torch.float16  # 新增类型约束
    assert bias.dtype == torch.float16
    pass
```

### 3. 逻辑修改（Logic Changes）

**定义**：改变算子的计算逻辑、数学公式或行为方式

**特点**：
- ❌ 改变计算公式或算法
- ❌ 改变输出结果的数学含义
- ❌ 添加新的计算步骤
- ✅ 必须同步修改所有四个文件

**常见逻辑修改**：
```python
# 修改前：简单广播
val_tile = tl.broadcast_to(bias_tile[None, :], (BLOCK_M, BLOCK_N))

# 修改后：广播后加ReLU激活
val_tile = tl.broadcast_to(bias_tile[None, :], (BLOCK_M, BLOCK_N))
val_tile = tl.maximum(val_tile, 0.0)  # ← 新增ReLU逻辑

# 修改后：广播后乘以缩放因子
val_tile = tl.broadcast_to(bias_tile[None, :], (BLOCK_M, BLOCK_N))
val_tile = val_tile * scale  # ← 新增缩放逻辑
```

---

## 判断流程图

```
开始修改
    ↓
┌─────────────────────────────────────┐
│ 问题1：我修改的是什么？              │
└─────────────────────────────────────┘
    ↓
    ├─→ BLOCK_M, BLOCK_N, num_warps, num_stages
    │   ↓
    │   【性能参数修改】
    │   只修改 _triton.py，其他文件不动
    │
    ├─→ 函数签名（参数个数、名称）
    │   ↓
    │   【接口修改】
    │   必须同步修改所有四个文件
    │
    ├─→ 数据类型要求（dtype）
    │   ↓
    │   【接口修改】
    │   必须同步修改所有四个文件
    │
    ├─→ 形状约束（assert检查）
    │   ↓
    │   【接口修改】
    │   必须同步修改所有四个文件
    │
    ├─→ 计算公式（数学运算）
    │   ↓
    │   【逻辑修改】
    │   必须同步修改所有四个文件
    │
    └─→ 添加新的计算步骤（如激活函数）
        ↓
        【逻辑修改】
        必须同步修改所有四个文件
```

---

## 详细判断标准

### 一、性能参数修改的判断标准

#### ✅ 属于性能参数修改的情况

| 修改内容 | 示例 | 说明 |
|---------|------|------|
| **BLOCK_M/BLOCK_N** | `BLOCK_M = 16 → 32` | 只影响块大小，不改变计算结果 |
| **num_warps** | `num_warps = 4 → 8` | 只影响线程组织，不改变计算结果 |
| **num_stages** | `num_stages = 2 → 3` | 只影响流水线，不改变计算结果 |
| **网格配置** | 一维网格 → 二维网格 | 只影响并行策略，不改变计算结果 |
| **内存对齐提示** | 添加 `tl.multiple_of(col_ids, 64)` | 只优化内存访问，不改变计算结果 |
| **Cache策略** | 添加 `eviction_policy='evict_last'` | 只优化缓存，不改变计算结果 |

#### 判断方法
```python
# 问自己以下问题：
1. 这个修改是否改变输入输出的数值？
   答：否 → 可能是性能参数

2. 这个修改是否改变函数的调用方式？
   答：否 → 可能是性能参数

3. 这个修改是否改变数学计算公式？
   答：否 → 可能是性能参数

4. 这个修改是否只影响GPU执行效率？
   答：是 → 确定是性能参数
```

### 二、接口修改的判断标准

#### ❌ 属于接口修改的情况

| 修改内容 | 示例 | 说明 |
|---------|------|------|
| **添加新参数** | `def func(x, y)` → `def func(x, y, z)` | 改变函数签名 |
| **删除参数** | `def func(x, y, z)` → `def func(x, y)` | 改变函数签名 |
| **改变参数类型** | `x: int` → `x: float` | 改变类型约束 |
| **添加类型约束** | 添加 `assert x.dtype == torch.float16` | 新增接口要求 |
| **修改形状约束** | 添加 `assert x.shape[-1] == 1024` | 新增形状要求 |
| **改变返回值** | `return tensor` → `return (tensor, extra_info)` | 改变返回值类型 |

#### 判断方法
```python
# 问自己以下问题：
1. 这个修改是否改变函数的参数个数或类型？
   答：是 → 确定是接口修改

2. 调用这个函数的方式是否需要改变？
   答：是 → 确定是接口修改

3. 是否添加了新的assert检查（类型/形状）？
   答：是 → 确定是接口修改

4. 其他文件调用这个函数时是否需要同步修改？
   答：是 → 确定是接口修改
```

### 三、逻辑修改的判断标准

#### ❌ 属于逻辑修改的情况

| 修改内容 | 示例 | 说明 |
|---------|------|------|
| **添加激活函数** | 添加 `val = relu(val)` | 改变计算逻辑 |
| **修改数学公式** | `out = x + y` → `out = x * y` | 改变计算结果 |
| **添加条件判断** | 添加 `if val > 0: val = 0` | 改变计算逻辑 |
| **添加缩放因子** | `out = out * scale` | 改变计算结果 |
| **修改广播方式** | 改变广播的维度或方向 | 改变计算逻辑 |
| **添加归一化** | 添加 `out = out / max_val` | 改变计算结果 |

#### 判断方法
```python
# 问自己以下问题：
1. 这个修改是否改变输出的数值结果？
   答：是 → 确定是逻辑修改

2. 这个修改是否改变算子的数学含义？
   答：是 → 确定是逻辑修改

3. 原有的计算公式是否被修改？
   答：是 → 确定是逻辑修改

4. 是否添加了新的数学运算步骤？
   答：是 → 确定是逻辑修改
```

---

## 实战案例解析

### 案例1：调整BLOCK_M和BLOCK_N

**代码修改**：
```python
# broadcast_v1_triton.py
# 修改前
BLOCK_N = 256
BLOCK_M = 16

# 修改后
BLOCK_N = 512
BLOCK_M = 32
```

**判断过程**：
```
1. 这个修改是否改变输入输出的数值？
   答：否，输出结果完全相同

2. 这个修改是否改变函数的调用方式？
   答：否，调用方式不变

3. 这个修改是否改变数学计算公式？
   答：否，公式仍然是 out = broadcast(bias)

4. 这个修改是否只影响GPU执行效率？
   答：是，只是调整了块大小以提高性能

结论：✅ 性能参数修改
操作：只需修改 _triton.py，其他三个文件不动
```

### 案例2：添加ReLU激活函数

**代码修改**：
```python
# broadcast_v1_triton.py
# 修改前
val_tile = tl.broadcast_to(bias_tile[None, :], (BLOCK_M, BLOCK_N))
tl.store(out_ptr + out_offsets, val_tile, mask=mask)

# 修改后
val_tile = tl.broadcast_to(bias_tile[None, :], (BLOCK_M, BLOCK_N))
val_tile = tl.maximum(val_tile, 0.0)  # ← 添加ReLU
tl.store(out_ptr + out_offsets, val_tile, mask=mask)
```

**判断过程**：
```
1. 这个修改是否改变输入输出的数值？
   答：是，负值被置为0

2. 这个修改是否改变算子的数学含义？
   答：是，从纯广播变为广播+ReLU

3. 原有的计算公式是否被修改？
   答：是，添加了激活函数

4. 是否添加了新的数学运算步骤？
   答：是，添加了max(0, x)操作

结论：❌ 逻辑修改
操作：必须同步修改所有四个文件
```

### 案例3：添加scale参数

**代码修改**：
```python
# broadcast_v1_triton.py
# 修改前
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    pass

# 修改后
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor, scale: float = 1.0) -> torch.Tensor:
    val_tile = tl.broadcast_to(bias_tile[None, :] * scale, (BLOCK_M, BLOCK_N))
```

**判断过程**：
```
1. 这个修改是否改变函数的参数个数？
   答：是，添加了scale参数

2. 调用这个函数的方式是否需要改变？
   答：是，调用时需要传入scale参数

3. 是否添加了新的接口要求？
   答：是，新增了scale参数

4. 其他文件调用这个函数时是否需要同步修改？
   答：是，_baseline.py、_accuracy.py、_performance.py都需要更新

结论：❌ 接口修改
操作：必须同步修改所有四个文件
```

### 案例4：添加数据类型约束

**代码修改**：
```python
# broadcast_v1_triton.py
# 修改前
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    assert x.is_npu and bias.is_npu

# 修改后
def broadcast_v1(x: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    assert x.is_npu and bias.is_npu
    assert x.dtype == torch.float16  # ← 新增类型约束
    assert bias.dtype == torch.float16
```

**判断过程**：
```
1. 这个修改是否改变函数的接口要求？
   答：是，新增了数据类型约束

2. 调用这个函数时是否需要满足新的要求？
   答：是，必须传入float16类型的张量

3. 是否添加了新的assert检查？
   答：是，添加了dtype检查

4. 其他文件调用这个函数时是否需要同步修改？
   答：是，_baseline.py、_accuracy.py、_performance.py都需要添加相同的约束

结论：❌ 接口修改
操作：必须同步修改所有四个文件
```

### 案例5：修改网格配置（一维→二维）

**代码修改**：
```python
# broadcast_v1_triton.py
# 修改前
pid = tl.program_id(axis=0)
row_ids = pid * BLOCK_M + tl.arange(0, BLOCK_M)
grid = lambda meta: (triton.cdiv(P * D, meta['BLOCK_M'] * meta['BLOCK_N']),)

# 修改后
pid_m = tl.program_id(axis=0)
pid_n = tl.program_id(axis=1)
row_ids = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)
col_ids = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)
grid = lambda meta: (triton.cdiv(P, meta['BLOCK_M']), triton.cdiv(D, meta['BLOCK_N']))
```

**判断过程**：
```
1. 这个修改是否改变输入输出的数值？
   答：否，输出结果完全相同

2. 这个修改是否改变函数的调用方式？
   答：否，调用方式不变

3. 这个修改是否改变数学计算公式？
   答：否，公式仍然是 out = broadcast(bias)

4. 这个修改是否只影响GPU执行策略？
   答：是，只是改变了网格划分方式以提高并行度

结论：✅ 性能参数修改
操作：只需修改 _triton.py，其他三个文件不动
```

---

## 快速检查清单

### 修改前必问的5个问题

在修改代码之前，先问自己这5个问题：

```
□ 问题1：我修改的是 BLOCK_M, BLOCK_N, num_warps, num_stages 吗？
  → 是 → 性能参数修改 → 只改 _triton.py

□ 问题2：我修改的是网格配置（一维/二维）吗？
  → 是 → 性能参数修改 → 只改 _triton.py

□ 问题3：我是否添加、删除或修改了函数参数？
  → 是 → 接口修改 → 必须修改所有四个文件

□ 问题4：我是否添加、删除或修改了assert检查？
  → 是 → 接口修改 → 必须修改所有四个文件

□ 问题5：我是否修改了计算公式或添加了新的数学运算？
  → 是 → 逻辑修改 → 必须修改所有四个文件
```

### 修改后验证清单

```
□ 如果是性能参数修改：
  ✓ _baseline.py 是否未修改？
  ✓ _accuracy.py 是否未修改？
  ✓ _performance.py 是否未修改？
  ✓ 函数签名是否未改变？
  ✓ 计算结果是否与修改前相同？

□ 如果是接口/逻辑修改：
  ✓ _baseline.py 是否已同步修改？
  ✓ _accuracy.py 是否已同步修改？
  ✓ _performance.py 是否已同步修改？
  ✓ 所有文件的函数签名是否一致？
  ✓ 所有文件的assert检查是否一致？
  ✓ 所有文件的计算逻辑是否一致？
```

---

## 常见修改场景速查表

| 修改场景 | 修改类型 | 需要修改的文件 |
|---------|---------|---------------|
| 调整 BLOCK_M/BLOCK_N | 性能参数 | 仅 _triton.py |
| 调整 num_warps/num_stages | 性能参数 | 仅 _triton.py |
| 修改网格配置（一维/二维） | 性能参数 | 仅 _triton.py |
| 添加内存对齐提示 | 性能参数 | 仅 _triton.py |
| 添加 cache 策略 | 性能参数 | 仅 _triton.py |
| 添加新函数参数 | 接口修改 | 所有四个文件 |
| 删除函数参数 | 接口修改 | 所有四个文件 |
| 修改参数类型 | 接口修改 | 所有四个文件 |
| 添加数据类型约束 | 接口修改 | 所有四个文件 |
| 添加形状约束 | 接口修改 | 所有四个文件 |
| 添加激活函数（ReLU） | 逻辑修改 | 所有四个文件 |
| 修改数学公式 | 逻辑修改 | 所有四个文件 |
| 添加缩放因子 | 逻辑修改 | 所有四个文件 |
| 添加条件判断 | 逻辑修改 | 所有四个文件 |
| 添加归一化操作 | 逻辑修改 | 所有四个文件 |

---

## 总结

### 核心原则

1. **性能参数修改**：只影响效率，不影响结果和接口
   - 只改 _triton.py
   - 其他文件完全不动

2. **接口修改**：改变函数的定义或约束
   - 必须同步修改所有四个文件
   - 保持接口一致性

3. **逻辑修改**：改变计算方式或数学含义
   - 必须同步修改所有四个文件
   - 保持逻辑一致性

### 判断口诀

```
改参数，不改值 → 性能参数 → 只改一个
改签名，改约束 → 接口修改 → 四个都改
改公式，加计算 → 逻辑修改 → 四个都改
```

### 实际操作流程

```
1. 明确修改意图
   ↓
2. 对照判断标准
   ↓
3. 确定修改类型
   ↓
4. 执行相应操作
   ↓
5. 运行测试验证
   ↓
6. 检查所有文件的一致性
```
